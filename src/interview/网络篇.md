# 网络安全篇

## XSS 分为哪几类?

根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。

### 存储型 XSS

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

### 反射型 XSS

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

例如：用户点击一个搜索结果链接，该链接的URL中包含了搜索的词汇。如果应用不正确地处理输入参数，搜索词汇可能会被包含在HTML中返回给用户，从而执行嵌入的恶意代码。



反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

### DOM 型 XSS （不需要服务端参与）

DOM 型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

例如：用户点击一个链接，链接的URL中包含了一个hash值（#后面的值）。页面的JavaScript可能会从hash值读取数据并将其插入到页面中，如果页面JavaScript未对这部分数据进行安全处理，则恶意代码就可能会被执行。

## 如何预发 XSS

XSS 攻击有两大要素：

- 攻击者提交恶意代码。
- 浏览器执行恶意代码。

### 预防反射型跟存储型

#### 过滤攻击者输入

使用 escapeHTML 函数，将<、>等转义成字符实体后存储，在用游览器就能正常展示。

#### 防止游览器执行恶意代码

1、使用纯前端渲染，通过js告诉游览器这是一段文本，如使用 .innerText 插入等
2、如果拼接html是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义

### 预防DOM型
DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。

在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。

### 其他 XSS 防范措施

1、严格的 CSP 在 XSS 的防范。 
* 禁止加载外域代码，防止复杂的攻击逻辑。
* 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
* 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。

2、输入内容长度控制、输入校验
3、HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。

## csrf
前置知识：Cookies 被设计为一种机制，允许服务器存储信息在用户的浏览器中，并且在用户之后的每次请求中，浏览器都会自动将这些信息发送回服务器（属于同一域）。这种行为是为了支持无状态的 HTTP 协议下的用户会话管理。

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求（该请求一般是跨域的）。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

一个典型的CSRF攻击有着如下的流程：

* 受害者登录 a.com，并保留了登录凭证（Cookie）
* 攻击者引诱受害者访问了b.com
* b.com 向 a.com 发送了一个请求：a.com/act=xx浏览器会默认携带a.com的Cookie
* a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
* a.com以受害者的名义执行了act=xx
* 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作

CSRF的特点
* 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
* 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
* 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
* 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

解决方法  
1、尽量使用post  
2、加入验证码（就是用户验证码，移动滑块，点击文字等各种，确保是真人）或者再次输入密码  
3、验证referer，进行同源检测  
4、CSRF Token  
5、Samesite Cookie属性

SameSite Cookie属性是一个用于防止跨站请求伪造（CSRF）攻击的安全功能。它允许服务器指定Cookie不应该随着来自第三方网站的请求一起发送。SameSite属性可以设置为以下三个值之一，以控制Cookies的发送行为：

Strict（严格）:  
SameSite=Strict属性会极限制Cookie的发送。当设置为Strict时，Cookie仅在当前网站的请求中被发送，即只有当请求的域与Cookie的域完全匹配时，浏览器才会包含这个Cookie。
这意味着即使用户通过点击链接从其他站点导航到使用了SameSite=Strict的网站上，也不会发送Cookie。这种限制在保护用户免受CSRF攻击方面非常有效，但可能影响用户体验，因为一些基于Cookie的跨站点功能（如单点登录）将无法工作。  
Lax（宽松）:  
SameSite=Lax提供了一种平衡方式，某些跨站点请求将允许发送Cookie，具体取决于请求类型和用户的操作。通常，只有当用户从第三方网站导航到设置了SameSite=Lax Cookie的网站时(比如通过点击链接)以及请求是GET方法时，Cookie才会被包含送出。
这对于防范CSRF攻击仍然很有效，同时允许了一些无害的跨站点请求（如导航）能够正常工作，提供了更好的用户体验。  
None（无）:  
SameSite=None属性使得Cookie在所有的跨站点请求中都会被发送。为了设置SameSite=None，Cookie还需要设置Secure属性，表示Cookie仅在安全上下文中（如HTTPS协议）被发送。  
这对于那些需要在多个不同域之间共享Cookie的应用非常有用，例如，在内容分发网络(CDN)或是SaaS应用中提供跨域认证服务的场景。






# 网络知识篇
